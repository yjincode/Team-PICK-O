name: Demo Deploy (ìž„ì‹œ í…ŒìŠ¤íŠ¸ - 1ì‹œê°„ í›„ ì¢…ë£Œ)

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  pre-deployment-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Validate deployment configuration
      env:
        # í…ŒìŠ¤íŠ¸ìš© ê¸°ë³¸ê°’ ì„¤ì • (ê²½ê³  ì œê±°)
        DATABASE_URL: "postgresql://postgres:password@database:5432/teamPicko"
        POSTGRES_DB: "teamPicko"
        POSTGRES_USER: "postgres"
        POSTGRES_PASSWORD: "password"
        SECRET_KEY: "test-secret-key"
        ALLOWED_HOSTS: "localhost,127.0.0.1"
        BACKEND_CORS_ORIGINS: '["http://localhost:3000"]'
        AWS_REGION: "ap-northeast-2"
      run: |
        echo "ðŸ” ë°°í¬ ì„¤ì • ê²€ì¦ ì¤‘..."
        cd deployment
        # Docker Compose v2 ì‚¬ìš© (docker compose)
        docker compose config
        echo "âœ… Docker Compose configuration is valid"

  deploy:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
      continue-on-error: false
    
    - name: Verify AWS credentials
      run: |
        echo "ðŸ” AWS ìžê²©ì¦ëª… í™•ì¸ ì¤‘..."
        aws sts get-caller-identity
        echo "âœ… AWS ìžê²©ì¦ëª… í™•ì¸ ì™„ë£Œ"
    
    - name: Check ECR repositories exist
      run: |
        echo "ðŸ” ECR ì €ìž¥ì†Œ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸ ì¤‘..."
        
        # Backend ECR ì €ìž¥ì†Œ í™•ì¸/ìƒì„±
        if ! aws ecr describe-repositories --repository-names ${{ secrets.ECR_REPOSITORY_BACKEND }} > /dev/null 2>&1; then
          echo "âš ï¸ Backend ECR ì €ìž¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. ìƒì„± ì¤‘..."
          aws ecr create-repository \
            --repository-name ${{ secrets.ECR_REPOSITORY_BACKEND }} \
            --image-scanning-configuration scanOnPush=true \
            --region ${{ secrets.AWS_REGION }}
          echo "âœ… Backend ECR ì €ìž¥ì†Œ ìƒì„± ì™„ë£Œ"
        else
          echo "âœ… Backend ECR ì €ìž¥ì†Œ ì¡´ìž¬ í™•ì¸"
        fi
        
        # Frontend ECR ì €ìž¥ì†Œ í™•ì¸/ìƒì„±
        if ! aws ecr describe-repositories --repository-names ${{ secrets.ECR_REPOSITORY_FRONTEND }} > /dev/null 2>&1; then
          echo "âš ï¸ Frontend ECR ì €ìž¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. ìƒì„± ì¤‘..."
          aws ecr create-repository \
            --repository-name ${{ secrets.ECR_REPOSITORY_FRONTEND }} \
            --image-scanning-configuration scanOnPush=true \
            --region ${{ secrets.AWS_REGION }}
          echo "âœ… Frontend ECR ì €ìž¥ì†Œ ìƒì„± ì™„ë£Œ"
        else
          echo "âœ… Frontend ECR ì €ìž¥ì†Œ ì¡´ìž¬ í™•ì¸"
        fi
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        mask-password: 'true'
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64
    
    - name: Build and push backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_BACKEND }}
        IMAGE_TAG: demo-${{ github.sha }}
        DOCKER_BUILDKIT: 1
      run: |
        echo "ðŸ” Backend ì´ë¯¸ì§€ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸ ì¤‘..."
        echo "ðŸ“ ECR Registry: $ECR_REGISTRY"
        echo "ðŸ“ Repository: $ECR_REPOSITORY"
        echo "ðŸ“ Tag: $IMAGE_TAG"
        
        # ì´ë¯¸ì§€ê°€ ì´ë¯¸ ì¡´ìž¬í•˜ëŠ”ì§€ í™•ì¸
        if aws ecr describe-images \
          --repository-name $ECR_REPOSITORY \
          --image-ids imageTag=$IMAGE_TAG \
          --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
          echo "âœ… Backend ì´ë¯¸ì§€ê°€ ì´ë¯¸ ì¡´ìž¬í•©ë‹ˆë‹¤. ë¹Œë“œë¥¼ ìŠ¤í‚µí•©ë‹ˆë‹¤."
          echo "ðŸ“¦ ê¸°ì¡´ ì´ë¯¸ì§€: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        else
          echo "ðŸ”¨ Backend ì´ë¯¸ì§€ ë¹Œë“œ ì¤‘..."
          
          # Docker context í™•ì¸
          cd backend
          ls -la
          
          # Backend ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ (Ubuntu ê¸°ë°˜, faster-whisper í¬í•¨)
          docker buildx build \
            --platform linux/amd64 \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --push \
            --progress=plain \
            -f Dockerfile \
            .
          
          echo "âœ… Backend ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ ì™„ë£Œ"
          echo "ðŸ“¦ ì´ë¯¸ì§€: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # í‘¸ì‹œëœ ì´ë¯¸ì§€ í™•ì¸
          aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --image-ids imageTag=$IMAGE_TAG \
            --region ${{ secrets.AWS_REGION }}
        fi
    
    - name: Build and push frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_FRONTEND }}
        IMAGE_TAG: demo-${{ github.sha }}
        DOCKER_BUILDKIT: 1
      run: |
        echo "ðŸ” Frontend ì´ë¯¸ì§€ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸ ì¤‘..."
        echo "ðŸ“ ECR Registry: $ECR_REGISTRY"
        echo "ðŸ“ Repository: $ECR_REPOSITORY"  
        echo "ðŸ“ Tag: $IMAGE_TAG"
        
        # ì´ë¯¸ì§€ê°€ ì´ë¯¸ ì¡´ìž¬í•˜ëŠ”ì§€ í™•ì¸
        if aws ecr describe-images \
          --repository-name $ECR_REPOSITORY \
          --image-ids imageTag=$IMAGE_TAG \
          --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
          echo "âœ… Frontend ì´ë¯¸ì§€ê°€ ì´ë¯¸ ì¡´ìž¬í•©ë‹ˆë‹¤. ë¹Œë“œë¥¼ ìŠ¤í‚µí•©ë‹ˆë‹¤."
          echo "ðŸ“¦ ê¸°ì¡´ ì´ë¯¸ì§€: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        else
          echo "ðŸ”¨ Frontend ì´ë¯¸ì§€ ë¹Œë“œ ì¤‘..."
          
          # Docker context í™•ì¸
          cd frontend
          ls -la
          
          # Frontend ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ (ê¶Œí•œ ë¬¸ì œ í•´ê²°ë¨)
          docker buildx build \
            --platform linux/amd64 \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --push \
            --progress=plain \
            -f Dockerfile \
            .
          
          echo "âœ… Frontend ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ ì™„ë£Œ"
          echo "ðŸ“¦ ì´ë¯¸ì§€: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # í‘¸ì‹œëœ ì´ë¯¸ì§€ í™•ì¸
          aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --image-ids imageTag=$IMAGE_TAG \
            --region ${{ secrets.AWS_REGION }}
        fi
    
    - name: Deploy to Demo EC2
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: demo-${{ github.sha }}
      run: |
        # ì‹œí¬ë¦¿ ê°’ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸
        echo "ðŸ” ì‹œí¬ë¦¿ ê°’ í™•ì¸:"
        echo "EC2_HOST: ${EC2_HOST:-'âŒ ì—†ìŒ'}"
        echo "EC2_USER: ${EC2_USER:-'âŒ ì—†ìŒ'}"
        echo "EC2_KEY ê¸¸ì´: ${#EC2_KEY}"
        
        if [ -z "$EC2_HOST" ] || [ -z "$EC2_USER" ] || [ -z "$EC2_KEY" ]; then
          echo "âŒ í•„ìˆ˜ ì‹œí¬ë¦¿ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤!"
          echo "EC2_HOST ì¡´ìž¬: $([ -n "$EC2_HOST" ] && echo 'O' || echo 'X')"
          echo "EC2_USER ì¡´ìž¬: $([ -n "$EC2_USER" ] && echo 'O' || echo 'X')"
          echo "EC2_KEY ì¡´ìž¬: $([ -n "$EC2_KEY" ] && echo 'O' || echo 'X')"
          exit 1
        fi
        
        echo "$EC2_KEY" > ec2_key.pem
        chmod 600 ec2_key.pem
        
        # GitHub Actions runner IP í™•ì¸
        echo "ðŸ” GitHub Actions runner IP:"
        curl -s http://checkip.amazonaws.com/
        
        # SSH í‚¤ íŒŒì¼ ê²€ì¦
        echo "ðŸ” SSH í‚¤ íŒŒì¼ ê²€ì¦:"
        ls -la ec2_key.pem
        echo "í‚¤ íŒŒì¼ ì²« ì¤„:"
        head -1 ec2_key.pem
        echo "í‚¤ íŒŒì¼ ë§ˆì§€ë§‰ ì¤„:"
        tail -1 ec2_key.pem
        
        # ë„¤íŠ¸ì›Œí¬ ì—°ê²° í…ŒìŠ¤íŠ¸
        echo "ðŸ” ë„¤íŠ¸ì›Œí¬ ì—°ê²° í…ŒìŠ¤íŠ¸:"
        nc -zv $EC2_HOST 22 || echo "âš ï¸ Port 22 ì—°ê²° ì‹¤íŒ¨"
        
        # SSH ì—°ê²° í…ŒìŠ¤íŠ¸ (ìƒì„¸ ë¡œê·¸)
        echo "ðŸ” SSH ì—°ê²° í…ŒìŠ¤íŠ¸:"
        ssh -vvv -i ec2_key.pem -o ConnectTimeout=30 -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "echo 'SSH ì—°ê²° ì„±ê³µ'" || {
          echo "âŒ SSH ì—°ê²° ì‹¤íŒ¨"
          echo "EC2_HOST: $EC2_HOST"
          echo "EC2_USER: $EC2_USER"
          exit 1
        }
        
        # Copy deployment files to EC2
        scp -i ec2_key.pem -o StrictHostKeyChecking=no \
          deployment/docker-compose.yml \
          deployment/nginx.conf \
          deployment/auto-shutdown.sh \
          $EC2_USER@$EC2_HOST:~/
        
        # Create .env file for docker-compose
        cat > deployment.env << EOL
        # Docker Images
        BACKEND_IMAGE=$ECR_REGISTRY/${{ secrets.ECR_REPOSITORY_BACKEND }}:$IMAGE_TAG
        FRONTEND_IMAGE=$ECR_REGISTRY/${{ secrets.ECR_REPOSITORY_FRONTEND }}:$IMAGE_TAG
        
        # Database Configuration (ì»¨í…Œì´ë„ˆ ê°„ í†µì‹ )
        POSTGRES_DB="${{ secrets.POSTGRES_DB }}"
        POSTGRES_USER="${{ secrets.POSTGRES_USER }}"
        POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
        DATABASE_URL="postgresql://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@database:5432/${{ secrets.POSTGRES_DB }}"
        
        # Database Connection Details for Django
        DB_HOST="database"
        DB_PORT="5432"
        DB_NAME="${{ secrets.POSTGRES_DB }}"
        DB_USER="${{ secrets.POSTGRES_USER }}"
        DB_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
        
        # Application Configuration
        DEBUG=False
        SECRET_KEY="${{ secrets.SECRET_KEY }}"
        ALLOWED_HOSTS="${{ secrets.ALLOWED_HOSTS }},badaejangbu.store,${{ secrets.EC2_HOST }}"
        PROJECT_NAME="Team-PICK-O Backend (Demo)"
        
        # Network Configuration (HTTPS í™œì„±í™”)
        REACT_APP_API_URL="https://badaejangbu.store/api"
        VITE_API_URL="https://badaejangbu.store/api"
        BACKEND_CORS_ORIGINS='["https://badaejangbu.store","https://www.badaejangbu.store","http://localhost:3000","http://localhost:5173","http://127.0.0.1:3000","http://127.0.0.1:5173","https://localhost:3000"]'
        
        # Ports (ë°ëª¨ìš©)
        FRONTEND_PORT=3000
        BACKEND_PORT=8000
        DB_PORT=5432
        HTTP_PORT=80
        
        # AWS Configuration (infraì—ì„œ ìƒì„±ëœ ë¦¬ì†ŒìŠ¤ ì—°ê²°)
        AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
        AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        AWS_S3_BUCKET_NAME="${{ secrets.AWS_S3_BUCKET_NAME }}"
        AWS_REGION="${{ secrets.AWS_REGION }}"
        
        # JWT ì¸ì¦ ì„¤ì • (Secretsì—ì„œ ì£¼ìž…)
        JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
        JWT_REFRESH_SECRET_KEY="${{ secrets.JWT_REFRESH_SECRET_KEY }}"
        
        # Firebase Admin SDK ì„¤ì • (Secretsì—ì„œ ì£¼ìž…)
        FIREBASE_ADMIN_CREDENTIALS_JSON='${{ secrets.FIREBASE_ADMIN_CREDENTIALS_JSON }}'
        
        # ì™¸ë¶€ ì„œë¹„ìŠ¤ ì„¤ì •
        TOSS_SECRET_KEY="${{ secrets.TOSS_SECRET_KEY }}"
        VITE_TOSS_CLIENT_KEY="${{ secrets.VITE_TOSS_CLIENT_KEY }}"
        DISCORD_WEBHOOK_URL="${{ secrets.DISCORD_WEBHOOK_URL }}"
        EOL
        
        # Copy env file to EC2
        scp -i ec2_key.pem -o StrictHostKeyChecking=no deployment.env $EC2_USER@$EC2_HOST:~/.env
        
        # Deploy on EC2
        ssh -i ec2_key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST << EOF
          # Emergency Docker cleanup first
          echo "ðŸš¨ ê¸´ê¸‰ Docker ì •ë¦¬ ì‹œìž‘..."
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          docker rmi $(docker images -q) 2>/dev/null || true
          docker system prune -af --volumes 2>/dev/null || true
          docker builder prune -af 2>/dev/null || true
          
          echo "ðŸ” ì •ë¦¬ í›„ ë””ìŠ¤í¬ ê³µê°„:"
          df -h
          
          # Configure AWS credentials on EC2
          export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
          export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          export AWS_DEFAULT_REGION="${{ secrets.AWS_REGION }}"
          
          # Set Firebase Admin SDK JSON for file creation
          export FIREBASE_ADMIN_CREDENTIALS_JSON='${{ secrets.FIREBASE_ADMIN_CREDENTIALS_JSON }}'
          
          echo "ðŸ” AWS ìžê²©ì¦ëª… í™•ì¸:"
          aws sts get-caller-identity || {
            echo "âŒ AWS ìžê²©ì¦ëª…ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
            exit 1
          }
          
          # ECR ë ˆì§€ìŠ¤íŠ¸ë¦¬ URL ì„¤ì •
          ECR_REGISTRY="522814725827.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com"
          echo "ðŸ” ECR ë ˆì§€ìŠ¤íŠ¸ë¦¬: $ECR_REGISTRY"
          
          # Login to ECR
          echo "ðŸ” ECR ë¡œê·¸ì¸ ì‹œë„..."
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REGISTRY
          
          if [ $? -eq 0 ]; then
            echo "âœ… ECR ë¡œê·¸ì¸ ì„±ê³µ"
          else
            echo "âŒ ECR ë¡œê·¸ì¸ ì‹¤íŒ¨"
            exit 1
          fi
          
          # Check disk space before deployment
          echo "ðŸ” ë°°í¬ ì „ ë””ìŠ¤í¬ ê³µê°„ í™•ì¸:"
          df -h
          
          # Stop existing containers (using production compose)
          docker compose --env-file ~/.env down || true
          
          # Create Firebase Admin SDK key file from environment variable
          echo "ðŸ”§ Firebase Admin SDK í‚¤ íŒŒì¼ ìƒì„± ì¤‘..."
          echo "ðŸ” í™˜ê²½ë³€ìˆ˜ í™•ì¸: FIREBASE_ADMIN_CREDENTIALS_JSON ê¸¸ì´: \$${#FIREBASE_ADMIN_CREDENTIALS_JSON}"
          
          # Check if Firebase credentials are available from GitHub Secrets
          if [ ! -z '${{ secrets.FIREBASE_ADMIN_CREDENTIALS_JSON }}' ]; then
            echo '${{ secrets.FIREBASE_ADMIN_CREDENTIALS_JSON }}' > firebase-admin-key.json
            echo "âœ… Firebase Admin SDK í‚¤ íŒŒì¼ ìƒì„± ì™„ë£Œ"
            ls -la firebase-admin-key.json
            # Verify file content (first line only for security)
            echo "ðŸ” íŒŒì¼ ë‚´ìš© ê²€ì¦ (ì²« ì¤„):"
            head -1 firebase-admin-key.json
          else
            echo "âš ï¸ GitHub Secrets FIREBASE_ADMIN_CREDENTIALS_JSONì´ ë¹„ì–´ ìžˆìŠµë‹ˆë‹¤"
            echo "ðŸ” í˜„ìž¬ ì„¤ì •ëœ í™˜ê²½ë³€ìˆ˜ë“¤:"
            env | grep FIREBASE || echo "Firebase ê´€ë ¨ í™˜ê²½ë³€ìˆ˜ ì—†ìŒ"
            # Create empty file to prevent directory creation
            touch firebase-admin-key.json
          fi
          
          # Clean up Docker resources to free space
          echo "ðŸ§¹ Docker ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì¤‘..."
          docker system prune -af --volumes || true
          docker builder prune -af || true
          
          # Check disk space after cleanup
          echo "ðŸ” ì •ë¦¬ í›„ ë””ìŠ¤í¬ ê³µê°„:"
          df -h
          
          # Pull latest images
          docker compose --env-file ~/.env pull
          
          # Check SSL certificate files and create appropriate nginx config
          echo "ðŸ” SSL ì¸ì¦ì„œ íŒŒì¼ í™•ì¸ ì¤‘..."
          if [ -f "/etc/letsencrypt/live/badaejangbu.store/fullchain.pem" ] && [ -f "/etc/letsencrypt/live/badaejangbu.store/privkey.pem" ]; then
            echo "âœ… SSL ì¸ì¦ì„œ íŒŒì¼ ì¡´ìž¬ í™•ì¸"
            ls -la /etc/letsencrypt/live/badaejangbu.store/
            echo "ðŸ”§ HTTPS í™œì„±í™”ëœ nginx ì„¤ì • ì‚¬ìš©"
          else
            echo "âš ï¸ SSL ì¸ì¦ì„œ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. HTTPë§Œ í™œì„±í™”í•©ë‹ˆë‹¤."
            # Create HTTP-only nginx config
            cat > nginx.conf << 'NGINX_EOF'
            events {
                worker_connections 1024;
            }
            
            http {
                upstream frontend {
                    server frontend:3000;
                }
            
                upstream backend {
                    server backend:8000;
                }
            
                server {
                    listen 80;
                    server_name badaejangbu.store www.badaejangbu.store;
            
                    # Frontend
                    location / {
                        proxy_pass http://frontend;
                        proxy_set_header Host \$host;
                        proxy_set_header X-Real-IP \$remote_addr;
                        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto \$scheme;
                    }
            
                    # Backend API
                    location /api/ {
                        proxy_pass http://backend/;
                        proxy_set_header Host \$host;
                        proxy_set_header X-Real-IP \$remote_addr;
                        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                        proxy_set_header X-Forwarded-Proto \$scheme;
                    }
                }
            }
            NGINX_EOF
            echo "ðŸ”§ HTTP-only nginx ì„¤ì • ìƒì„± ì™„ë£Œ"
          fi
          
          # Start new containers in production mode
          if [ -f "/etc/letsencrypt/live/badaejangbu.store/fullchain.pem" ]; then
            # SSL ì¸ì¦ì„œê°€ ìžˆëŠ” ê²½ìš° - ë³¼ë¥¨ ë§ˆìš´íŠ¸ ì¶”ê°€
            echo "ðŸ”§ SSL ì¸ì¦ì„œì™€ í•¨ê»˜ ì»¨í…Œì´ë„ˆ ì‹œìž‘"
            docker compose --env-file ~/.env up -d
            docker compose --env-file ~/.env exec -T nginx sh -c "mkdir -p /etc/letsencrypt" || true
            docker cp /etc/letsencrypt nginx:/etc/ || true
          else
            # SSL ì¸ì¦ì„œê°€ ì—†ëŠ” ê²½ìš° - HTTPë§Œ
            echo "ðŸ”§ HTTPë§Œìœ¼ë¡œ ì»¨í…Œì´ë„ˆ ì‹œìž‘"
            docker compose --env-file ~/.env up -d
          fi
          
          # Copy Firebase Admin SDK key to backend container
          echo "ðŸ”§ Firebase Admin SDK í‚¤ íŒŒì¼ì„ ë°±ì—”ë“œ ì»¨í…Œì´ë„ˆì— ë³µì‚¬ ì¤‘..."
          if [ -f "firebase-admin-key.json" ]; then
            # Wait for backend container to be ready
            sleep 10
            docker cp firebase-admin-key.json teamPicko-backend:/app/firebase-admin-key.json
            echo "âœ… Firebase Admin SDK í‚¤ íŒŒì¼ ë³µì‚¬ ì™„ë£Œ"
            
            # Verify the file in container
            docker exec teamPicko-backend ls -la /app/firebase-admin-key.json || echo "âš ï¸ íŒŒì¼ ë³µì‚¬ í™•ì¸ ì‹¤íŒ¨"
            
            # Restart backend container to reload Firebase SDK
            echo "ðŸ”„ ë°±ì—”ë“œ ì»¨í…Œì´ë„ˆ ìž¬ì‹œìž‘ ì¤‘..."
            docker compose --env-file ~/.env restart backend
          else
            echo "âš ï¸ firebase-admin-key.json íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤"
          fi
          
          # Wait for services to be healthy
          sleep 50
          
          # Check if services are running
          docker compose --env-file ~/.env ps
          
          # Check backend logs if unhealthy
          echo "ðŸ” ë°±ì—”ë“œ ì»¨í…Œì´ë„ˆ ë¡œê·¸ í™•ì¸:"
          docker logs teamPicko-backend --tail 50 || true
          
          echo "ðŸ” ë°ì´í„°ë² ì´ìŠ¤ ì»¨í…Œì´ë„ˆ ë¡œê·¸ í™•ì¸:"
          docker logs teamPicko-database --tail 20 || true
          
          # Verify services are accessible
          echo "ðŸ” ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸ ì¤‘..."
          curl -f http://localhost/ || echo "âš ï¸ Nginx health check failed"
          curl -f http://localhost:3000/ || echo "âš ï¸ Frontend check failed"
          curl -f http://localhost:8000/health/ || echo "âš ï¸ Backend check failed"
          
          # Additional debugging if backend fails
          if ! curl -f http://localhost:8000/health/ 2>/dev/null; then
            echo "ðŸ” ë°±ì—”ë“œ ë””ë²„ê¹… ì •ë³´:"
            docker exec teamPicko-backend ps aux || true
            docker exec teamPicko-backend netstat -tlnp || echo "netstat not available"
          fi
          
          # Setup auto-shutdown after 1 hour
          chmod +x auto-shutdown.sh
          ./auto-shutdown.sh 1
          echo "âœ… ë°ëª¨ ë°°í¬ ì™„ë£Œ - 1ì‹œê°„ í›„ ìžë™ ì¢…ë£Œ"
          echo "ðŸŒ Frontend: http://${{ secrets.EC2_HOST }}"
          echo "ðŸ”§ Backend API: http://${{ secrets.EC2_HOST }}:8000"
        EOF
        
        rm ec2_key.pem
    
    - name: Health Check
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
      run: |
        sleep 30
        echo "ðŸ” ì™¸ë¶€ì—ì„œ ì„œë¹„ìŠ¤ ì ‘ê·¼ í…ŒìŠ¤íŠ¸..."
        curl -f http://$EC2_HOST/ || echo "âš ï¸ Nginx ì™¸ë¶€ ì ‘ê·¼ ì‹¤íŒ¨"
        curl -f http://$EC2_HOST:3000/ || echo "âš ï¸ Frontend ì™¸ë¶€ ì ‘ê·¼ ì‹¤íŒ¨"  
        curl -f http://$EC2_HOST:8000/api/v1/ || echo "âš ï¸ Backend ì™¸ë¶€ ì ‘ê·¼ ì‹¤íŒ¨"
        echo "âœ… ë°ëª¨ ë°°í¬ ì„±ê³µ"
    
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "ðŸš€ ë°ëª¨ ë°°í¬ ì„±ê³µ! EC2 ì„œë²„ê°€ 1ì‹œê°„ í›„ ìžë™ ì¢…ë£Œë©ë‹ˆë‹¤."
          echo "ì ‘ì† URL: http://${{ secrets.EC2_HOST }}"
        else
          echo "âŒ ë°ëª¨ ë°°í¬ ì‹¤íŒ¨! ë¡œê·¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
        fi

  rollback:
    runs-on: ubuntu-latest
    if: failure()
    needs: deploy
    
    steps:
    - name: Rollback deployment
      env:
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_USER: ${{ secrets.EC2_USER }}
        EC2_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
      run: |
        echo "$EC2_KEY" > ec2_key.pem
        chmod 600 ec2_key.pem
        
        ssh -i ec2_key.pem -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST << EOF
          # Stop current deployment
          docker compose --env-file ~/.env down
          
          # Pull and start last known good images
          docker compose --env-file ~/.env pull
          docker compose --env-file ~/.env up -d
          
          echo "ðŸ”„ ë¡¤ë°±ëœ ì„œë¹„ìŠ¤ ìƒíƒœ:"
          docker compose --env-file ~/.env ps
        EOF
        
        rm ec2_key.pem
        echo "ðŸ”„ ë¡¤ë°± ì™„ë£Œ"